---
name: Godotä»£ç /åœºæ™¯è‡ªåŠ¨æ£€é”™ä¿®å¤å¸ˆï¼ˆgodot-mcpä¸“å±ï¼‰
description: é’ˆå¯¹ä¼‘é—²æ¸¸æˆdemoï¼Œåœ¨æ¯æ¬¡UIä¼˜åŒ–Skillæ”¹åŠ¨ä»£ç /åœºæ™¯åï¼Œè‡ªåŠ¨è°ƒç”¨godot-mcpå·¥å…·æ£€æµ‹è¯­æ³•é”™è¯¯ã€è¿è¡Œæ—¶BUGã€åœºæ™¯é…ç½®é—®é¢˜ï¼Œç²¾å‡†å®šä½é”™è¯¯ä½ç½®ï¼Œç”Ÿæˆä¿®å¤æ–¹æ¡ˆå¹¶æ”¯æŒè‡ªåŠ¨ä¿®å¤ï¼Œæ— éœ€æ‰‹åŠ¨é€ä¸ªæ’æŸ¥
---

version: "1.0.0"
tags: ["Godot", "ä¼‘é—²æ¸¸æˆ", "ä»£ç æ£€é”™", "BUGä¿®å¤", "godot-mcp", "UIä¼˜åŒ–åæ£€é”™"]
trigger: "å½“ç”¨æˆ·é€šè¿‡å…¶ä»–Skillï¼ˆå¦‚UIä¼˜åŒ–/é€‚é…ï¼‰æ”¹åŠ¨Godotä»£ç /åœºæ™¯åï¼Œè§¦å‘è‡ªåŠ¨æ£€é”™ï¼›æˆ–ç”¨æˆ·ä¸»åŠ¨è¦æ±‚æ£€æµ‹ä»£ç é”™è¯¯æ—¶è§¦å‘ï¼Œè‡ªåŠ¨è°ƒç”¨godot-mcpå®Œæˆå…¨æµç¨‹æ£€é”™ä¿®å¤"
---

## æ ¸å¿ƒæµç¨‹ï¼ˆæ·±åº¦ç»‘å®šgodot-mcpå·¥å…·ï¼‰
1. **æ£€é”™å‰ç½®å‡†å¤‡**ï¼š
   - è¯†åˆ«æœ¬æ¬¡ä»£ç /åœºæ™¯æ”¹åŠ¨èŒƒå›´ï¼ˆUI ç›¸å…³çš„ .gd è„šæœ¬ã€.tscn åœºæ™¯æ–‡ä»¶ï¼‰
   - è°ƒç”¨ godot-mcp çš„ `list_projects` å·¥å…·ï¼Œå®šä½æ”¹åŠ¨æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
2. **å¤šç»´åº¦è‡ªåŠ¨æ£€é”™ï¼ˆgodot-mcp å·¥å…·è°ƒç”¨é“¾ï¼‰**ï¼š
   - ğŸ”¹ **è¯­æ³•é™æ€æ£€æµ‹**ï¼šè°ƒç”¨ `run_project` ä»¥ `--headless --check-only` æ¨¡å¼å¯åŠ¨é¡¹ç›®ï¼Œæ£€æµ‹è„šæœ¬è¯­æ³•é”™è¯¯ã€åœºæ™¯èŠ‚ç‚¹é…ç½®é”™è¯¯ï¼ˆæ— éœ€è¿è¡Œæ¸¸æˆï¼‰
   - ğŸ”¹ **è¿è¡Œæ—¶åŠ¨æ€æ£€æµ‹**ï¼šè°ƒç”¨ `run_project` æ­£å¸¸å¯åŠ¨ demoï¼Œè§¦å‘ UI ç›¸å…³é€»è¾‘ï¼ˆå¦‚ç‚¹å‡»æŒ‰é’®ã€åŠ è½½UIåœºæ™¯ï¼‰
   - ğŸ”¹ **é”™è¯¯æ—¥å¿—é‡‡é›†**ï¼šè°ƒç”¨ `get_debug_output` å·¥å…·ï¼Œè¿‡æ»¤å¹¶æå–æ‰€æœ‰é”™è¯¯æ—¥å¿—ï¼ˆè¯­æ³•é”™è¯¯/è¿è¡Œæ—¶å¼‚å¸¸/èŠ‚ç‚¹ä¸å­˜åœ¨/ä¿¡å·ç»‘å®šå¤±è´¥ç­‰ï¼‰
   - ğŸ”¹ **é”™è¯¯åˆ†ç±»è§£æ**ï¼šå°†é”™è¯¯åˆ†ä¸ºã€Œè‡´å‘½é”™è¯¯ï¼ˆæ— æ³•è¿è¡Œï¼‰ã€ã€Œæ™®é€šé”™è¯¯ï¼ˆåŠŸèƒ½å¼‚å¸¸ï¼‰ã€ã€Œè­¦å‘Šï¼ˆä¸å½±å“è¿è¡Œï¼‰ã€ä¸‰ç±»
3. **é”™è¯¯å®šä½ä¸ä¿®å¤æ–¹æ¡ˆç”Ÿæˆ**ï¼š
   - è§£æé”™è¯¯æ—¥å¿—ä¸­çš„ã€Œæ–‡ä»¶è·¯å¾„ã€è¡Œå·ã€é”™è¯¯ç±»å‹ã€ï¼Œç²¾å‡†å®šä½åˆ°æ”¹åŠ¨çš„ä»£ç /åœºæ™¯èŠ‚ç‚¹
   - é’ˆå¯¹ä¸åŒé”™è¯¯ç±»å‹ç”Ÿæˆåˆ†çº§ä¿®å¤æ–¹æ¡ˆï¼š
     âœ… ç®€å•é”™è¯¯ï¼ˆå¦‚è¯­æ³•æ‹¼å†™é”™è¯¯ã€èŠ‚ç‚¹åå†™é”™ï¼‰ï¼šè‡ªåŠ¨ç”Ÿæˆä¿®å¤ä»£ç /é…ç½®
     âœ… å¤æ‚é”™è¯¯ï¼ˆå¦‚ä¿¡å·ç»‘å®šå¤±è´¥ã€é”šç‚¹é…ç½®é”™è¯¯ï¼‰ï¼šç»™å‡ºåˆ†æ­¥ä¿®å¤æŒ‡å¯¼
     âœ… æ½œåœ¨BUGï¼ˆå¦‚å†…å­˜æ³„æ¼ã€é¢‘ç¹é‡ç»˜ï¼‰ï¼šç»™å‡ºä¼˜åŒ–å»ºè®®
4. **è‡ªåŠ¨ä¿®å¤ä¸éªŒè¯**ï¼š
   - å¯¹ç®€å•é”™è¯¯ï¼šè°ƒç”¨ `add_node`/`modify_node` å·¥å…·è‡ªåŠ¨ä¿®æ”¹ä»£ç /åœºæ™¯å±æ€§
   - å¯¹å¤æ‚é”™è¯¯ï¼šè¾“å‡ºè¯¦ç»†ä¿®å¤æ­¥éª¤ï¼Œç­‰å¾…ç”¨æˆ·ç¡®è®¤åè¾…åŠ©æ‰§è¡Œ
   - ä¿®å¤åå†æ¬¡è°ƒç”¨ `run_project` + `get_debug_output` éªŒè¯é”™è¯¯æ˜¯å¦è§£å†³
5. **é”™è¯¯å¤„ç†**ï¼š
   - è‹¥ godot-mcp è¿”å›ã€Œé¡¹ç›®å¯åŠ¨å¤±è´¥ã€ï¼šå…ˆæ£€æµ‹ `project.godot` é…ç½®é”™è¯¯ï¼Œä¼˜å…ˆä¿®å¤åŸºç¡€é…ç½®
   - è‹¥ã€Œé”™è¯¯æ—¥å¿—ä¸ºç©ºã€ï¼šéªŒè¯é¡¹ç›®æ˜¯å¦æ­£å¸¸è¿è¡Œï¼Œè§¦å‘ UI äº¤äº’åé‡æ–°é‡‡é›†æ—¥å¿—
   - è‹¥ã€Œä¿®å¤åä»æŠ¥é”™ã€ï¼šå¯¹æ¯”æ”¹åŠ¨å‰åä»£ç ï¼Œå®šä½ä¿®å¤é—æ¼ç‚¹

## è¾“å‡ºå†…å®¹ï¼ˆgodot-mcpå…¼å®¹ï¼‰
- ğŸ” é”™è¯¯æ£€æµ‹æŠ¥å‘Šï¼ˆå«é”™è¯¯ç±»å‹ã€æ–‡ä»¶è·¯å¾„ã€è¡Œå·ã€é”™è¯¯æè¿°ï¼‰
- ğŸ› ï¸ åˆ†çº§ä¿®å¤æ–¹æ¡ˆï¼ˆè‡ªåŠ¨ä¿®å¤/æ‰‹åŠ¨ä¿®å¤æ­¥éª¤ï¼‰
- âœ… ä¿®å¤éªŒè¯ç»“æœï¼ˆä¿®å¤åæ˜¯å¦ä»æœ‰é”™è¯¯ï¼‰
- ğŸ“ é”™è¯¯æ—¥å¿—åŸå§‹æ–‡ä»¶ï¼ˆä¾¿äºäºŒæ¬¡æ’æŸ¥ï¼‰

## æ ¸å¿ƒGDScriptç¤ºä¾‹ï¼ˆMCPè‡ªåŠ¨æ³¨å…¥çš„é”™è¯¯æ£€æµ‹é€»è¾‘ï¼‰
```gdscript
# ç”±MCPè‡ªåŠ¨ç”Ÿæˆçš„é”™è¯¯æ£€æµ‹ä¸ä¿®å¤è¾…åŠ©è„šæœ¬
extends Node
var mcp_error_log: Array = [] # å­˜å‚¨godot-mcpè·å–çš„é”™è¯¯æ—¥å¿—
var fix_records: Array = [] # ä¿®å¤è®°å½•

func _ready():
    # è°ƒç”¨godot-mcpå¯åŠ¨æ£€é”™æµç¨‹
    call_mcp_tool("start_error_check", {"project_path": "/Users/xxx/godot-projects/casual-demo"})

# æ¥æ”¶godot-mcpè¿”å›çš„é”™è¯¯æ—¥å¿—å¹¶è§£æ
func _on_mcp_error_log_loaded(logs: Array):
    mcp_error_log = logs
    # åˆ†ç±»è§£æé”™è¯¯
    var syntax_errors = [] # è¯­æ³•é”™è¯¯
    var runtime_errors = [] # è¿è¡Œæ—¶é”™è¯¯
    var scene_errors = [] # åœºæ™¯é…ç½®é”™è¯¯
    
    for log in logs:
        if "Parse Error" in log or "SyntaxError" in log:
            syntax_errors.append(parse_error(log))
        elif "Invalid get index" in log or "Node not found" in log:
            runtime_errors.append(parse_error(log))
        elif "Scene configuration error" in log or "Anchor preset invalid" in log:
            scene_errors.append(parse_error(log))
    
    # è¾“å‡ºé”™è¯¯æŠ¥å‘Š
    print("=== Godot é”™è¯¯æ£€æµ‹æŠ¥å‘Š ===")
    print(f"è¯­æ³•é”™è¯¯: {len(syntax_errors)} ä¸ª")
    print(f"è¿è¡Œæ—¶é”™è¯¯: {len(runtime_errors)} ä¸ª")
    print(f"åœºæ™¯é…ç½®é”™è¯¯: {len(scene_errors)} ä¸ª")
    
    # è‡ªåŠ¨ä¿®å¤ç®€å•é”™è¯¯
    fix_simple_errors(syntax_errors + scene_errors)
    # è¾“å‡ºå¤æ‚é”™è¯¯ä¿®å¤æ­¥éª¤
    print_complex_fix_guide(runtime_errors)
    
    # éªŒè¯ä¿®å¤ç»“æœ
    call_mcp_tool("verify_fix", {"project_path": "/Users/xxx/godot-projects/casual-demo"})

# è§£æé”™è¯¯æ—¥å¿—ï¼Œæå–å…³é”®ä¿¡æ¯ï¼ˆè·¯å¾„ã€è¡Œå·ã€åŸå› ï¼‰
func parse_error(log: String) -> Dictionary:
    var error_info = {
        "file": "",
        "line": 0,
        "reason": "",
        "type": ""
    }
    # åŒ¹é…Godoté”™è¯¯æ—¥å¿—æ ¼å¼ï¼šres://scripts/ui/main_ui.gd:15 - Parse Error: Unexpected token
    var regex = RegEx.new()
    regex.compile(r"res://(.*):(\d+) - (.*)")
    var match = regex.search(log)
    if match:
        error_info["file"] = "res://" + match.get_string(1)
        error_info["line"] = int(match.get_string(2))
        error_info["reason"] = match.get_string(3)
        # è¯†åˆ«é”™è¯¯ç±»å‹
        if "Parse Error" in error_info["reason"]:
            error_info["type"] = "syntax"
        elif "Node not found" in error_info["reason"]:
            error_info["type"] = "node"
        elif "Anchor" in error_info["reason"]:
            error_info["type"] = "scene"
    return error_info

# è‡ªåŠ¨ä¿®å¤ç®€å•é”™è¯¯ï¼ˆgodot-mcpæ‰§è¡Œï¼‰
func fix_simple_errors(errors: Array[Dictionary]):
    for err in errors:
        var fix_result = false
        # ä¿®å¤1ï¼šè¯­æ³•é”™è¯¯ - ç¼ºå°‘åˆ†å·
        if "Unexpected token" in err.reason and "syntax" == err.type:
            fix_result = call_mcp_tool("modify_script", {
                "file_path": err.file,
                "line": err.line,
                "replace": "æ·»åŠ åˆ†å·ç»“å°¾"
            })
        # ä¿®å¤2ï¼šèŠ‚ç‚¹åé”™è¯¯ï¼ˆå¦‚StartBtnå†™æˆStartBtï¼‰
        elif "Node not found: StartBt" in err.reason:
            fix_result = call_mcp_tool("modify_node", {
                "scene_path": err.file.replace(".gd", ".tscn"),
                "node_path": "/Control/StartBt",
                "new_name": "StartBtn"
            })
        # ä¿®å¤3ï¼šé”šç‚¹é¢„è®¾å€¼é”™è¯¯ï¼ˆä¼‘é—²æ¸¸æˆç§»åŠ¨ç«¯é€‚é…å¸¸è§ï¼‰
        elif "Anchor preset invalid" in err.reason:
            fix_result = call_mcp_tool("modify_node", {
                "scene_path": err.file,
                "node_path": err.reason.split(":")[1].strip(),
                "properties": {"anchors_preset": 8} # è®¾ä¸ºä¸‹æ–¹å±…ä¸­
            })
        # è®°å½•ä¿®å¤ç»“æœ
        fix_records.append({
            "error": err,
            "fixed": fix_result,
            "fix_type": "auto"
        })

# è¾“å‡ºå¤æ‚é”™è¯¯ä¿®å¤æŒ‡å¯¼
func print_complex_fix_guide(errors: Array[Dictionary]):
    print("\n=== éœ€æ‰‹åŠ¨ä¿®å¤çš„é”™è¯¯ ===")
    for i, err in enumerate(errors):
        print(f"{i+1}. æ–‡ä»¶: {err.file} è¡Œå·: {err.line}")
        print(f"   é”™è¯¯åŸå› : {err.reason}")
        # é’ˆå¯¹UIä¼˜åŒ–å¸¸è§é”™è¯¯ç»™å‡ºä¿®å¤å»ºè®®
        if "signal 'pressed' is not connected" in err.reason:
            print(f"   ä¿®å¤æ­¥éª¤: 1. æ‰“å¼€{err.file}åœºæ™¯ â†’ 2. é€‰ä¸­ç›®æ ‡æŒ‰é’® â†’ 3. åœ¨ä¿¡å·é¢æ¿ç»‘å®špressedä¿¡å·åˆ°å¯¹åº”å‡½æ•°")
        elif "modulate:a" in err.reason: # é€æ˜åº¦èµ‹å€¼é”™è¯¯
            print(f"   ä¿®å¤æ­¥éª¤: å°†ä»£ç ä¸­'modulate:a'æ”¹ä¸º'modulate/alpha'ï¼Œæˆ–ä½¿ç”¨Color(1,1,1,0)è®¾ç½®é€æ˜åº¦")
        elif "Draw call exceeds limit" in err.reason: # UIæ€§èƒ½é”™è¯¯
            print(f"   ä¿®å¤æ­¥éª¤: åˆå¹¶é™æ€UIèŠ‚ç‚¹ â†’ å‹ç¼©çº¹ç†å°ºå¯¸ â†’ å‡å°‘é¢‘ç¹queue_redrawè°ƒç”¨")
        print("---")